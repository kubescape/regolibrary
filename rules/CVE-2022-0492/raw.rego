package armo_builtins


# Case 1: 
# -	Container runs as root OR allows privilege escalation (allowPrivilegeEscalation  = true or not present), AND
# -	No AppArmor , AND
# -	No SELinux, AND
# -	No Seccomp
#  If container is privileged or has CAP_SYS_ADMIN, don't fail

deny[msga] {
    pod := input[_]
    pod.kind == "Pod"
    container := pod.spec.containers[i]
	
	# Path to send
	beggining_of_path := "spec"
	
	# If container is privileged or has CAP_SYS_ADMIN, pass
    not container.securityContext.privileged == true
	not is_cap_sys_admin(container, beggining_of_path)

	
	is_no_SELinux_No_AppArmor_Pod(pod)
    is_no_seccomp_pod(pod)

    is_no_SELinux_container(container)
    is_no_Seccomp_Container(container)

	# Check if is running as root
    alertInfo :=  evaluate_workload_non_root_container(container, pod, beggining_of_path)

	# CAP_DAC_OVERRIDE will fail on second check
	not isCAP_DAC_OVERRIDE(container, beggining_of_path, i)

    # Get paths
	fixPath := get_fixed_path(alertInfo, i)
    failed_path := get_failed_path(alertInfo, i) 


	msga := {
		"alertMessage": "You may be vulnerable to CVE-2022-0492",
		"packagename": "armo_builtins",
		"alertScore": 4,
		"failedPaths": failed_path,
        "fixPaths": fixPath,
		"alertObject": {
			"k8sApiObjects": [pod]
		}
	}
}

deny[msga] {
    wl := input[_]
	spec_template_spec_patterns := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
	spec_template_spec_patterns[wl.kind]
	beggining_of_path := "spec.template.spec"

    pod := wl.spec.template
    container := pod.spec.containers[i]

    # If container is privileged or has CAP_SYS_ADMIN, pass
    not container.securityContext.privileged == true
	not is_cap_sys_admin(container, beggining_of_path)

	
	is_no_SELinux_No_AppArmor_Pod(pod)
    is_no_seccomp_pod(pod)

    is_no_SELinux_container(container)
    is_no_Seccomp_Container(container)

	# Check if is running as root
    alertInfo :=  evaluate_workload_non_root_container(container, pod, beggining_of_path)

	# CAP_DAC_OVERRIDE will fail on second check
	not isCAP_DAC_OVERRIDE(container, beggining_of_path, i)

    # Get paths
	fixPath := get_fixed_path(alertInfo, i)
    failed_path := get_failed_path(alertInfo, i)


	msga := {
		"alertMessage": "You may be vulnerable to CVE-2022-0492",
		"packagename": "armo_builtins",
		"alertScore": 4,
		"failedPaths": failed_path,
        "fixPaths": fixPath,
		"alertObject": {
			"k8sApiObjects": [wl]
		}
	}
}

deny[msga] {
  	wl := input[_]
	wl.kind == "CronJob"
	beggining_of_path := "spec.jobTemplate.spec.template.spec"

	pod := wl.spec.jobTemplate.spec.template
    container = pod.spec.containers[i]
    
   	# If container is privileged or has CAP_SYS_ADMIN, pass
    not container.securityContext.privileged == true
	not is_cap_sys_admin(container, beggining_of_path)

	
	is_no_SELinux_No_AppArmor_Pod(pod)
    is_no_seccomp_pod(pod)

    is_no_SELinux_container(container)
    is_no_Seccomp_Container(container)

	# Check if is running as root
    alertInfo :=  evaluate_workload_non_root_container(container, pod, beggining_of_path)

	# CAP_DAC_OVERRIDE will fail on second check
	not isCAP_DAC_OVERRIDE(container, beggining_of_path, i)

    # Get paths
	fixPath := get_fixed_path(alertInfo, i)
    failed_path := get_failed_path(alertInfo, i)

    msga := {
		"alertMessage": "You may be vulnerable to CVE-2022-0492",
		"packagename": "armo_builtins",
		"alertScore": 4,
		"failedPaths": failed_path,
        "fixPaths": fixPath,
		"alertObject": {
			"k8sApiObjects": [wl]
		}
	}
}


#################################################################################
# Case 2: 
# - Container has CAP_DAC_OVERRIDE capability, AND
# - No AppArmor, AND
# - No SELinux
#   If container is privileged or has CAP_SYS_ADMIN, don't fail

deny[msga] {
    pod := input[_]
    pod.kind == "Pod"
    container := pod.spec.containers[i]

	beggining_of_path := "spec."
	
    result := isCAP_DAC_OVERRIDE(container, beggining_of_path, i)

	# If container is privileged or has CAP_SYS_ADMIN, pass
    not container.securityContext.privileged == true
	not is_cap_sys_admin(container, beggining_of_path)

	is_no_SELinux_No_AppArmor_Pod(pod)
    is_no_SELinux_container(container)

	msga := {
		"alertMessage": "You may be vulnerable to CVE-2022-0492",
		"packagename": "armo_builtins",
		"alertScore": 4,
		"failedPaths": [result],
        "fixPaths": [],
		"alertObject": {
			"k8sApiObjects": [pod]
		}
	}
}

deny[msga] {
    wl := input[_]
	spec_template_spec_patterns := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
	spec_template_spec_patterns[wl.kind]

    pod := wl.spec.template
    container := pod.spec.containers[i]

	beggining_of_path := "spec.template.spec."

    result := isCAP_DAC_OVERRIDE(container, beggining_of_path, i)

	# If container is privileged or has CAP_SYS_ADMIN, pass
    not container.securityContext.privileged == true
	not is_cap_sys_admin(container, beggining_of_path)

	is_no_SELinux_No_AppArmor_Pod(pod)
    is_no_SELinux_container(container)

	msga := {
		"alertMessage": "You may be vulnerable to CVE-2022-0492",
		"packagename": "armo_builtins",
		"alertScore": 4,
		"failedPaths": [result],
        "fixPaths": [],
		"alertObject": {
			"k8sApiObjects": [wl]
		}
	}
}

deny[msga] {
  	wl := input[_]
	wl.kind == "CronJob"
    
    pod := wl.spec.jobTemplate.spec.template
    container = pod.spec.containers[i]
	
	beggining_of_path := "spec.jobTemplate.spec.template.spec."

   	result := isCAP_DAC_OVERRIDE(container, beggining_of_path, i)

	# If container is privileged or has CAP_SYS_ADMIN, pass
    not container.securityContext.privileged == true
	not is_cap_sys_admin(container, beggining_of_path)

	is_no_SELinux_No_AppArmor_Pod(pod)
    is_no_SELinux_container(container)

    msga := {
		"alertMessage": "You may be vulnerable to CVE-2022-0492",
		"packagename": "armo_builtins",
		"alertScore": 4,
		"failedPaths": [result],
        "fixPaths": [],
		"alertObject": {
			"k8sApiObjects": [wl]
		}
	}
}




is_cap_sys_admin(container, beggining_of_path) {
	capability = container.securityContext.capabilities.add[k]
    capability == "SYS_ADMIN"
}

isCAP_DAC_OVERRIDE(container, beggining_of_path, i) = path {
	capability = container.securityContext.capabilities.add[k]
    capability == "DAC_OVERRIDE"
    path = sprintf("%vcontainers[%v].securityContext.capabilities.add[%v]", [beggining_of_path, format_int(i, 10), format_int(k, 10)]) 
}



#################################################################################

get_failed_path(alertInfo, i) = [replace(alertInfo.failed_path,"container_ndx",format_int(i,10))] {
	alertInfo.failed_path != ""
} else = []


get_fixed_path(alertInfo, i) = [{"path":replace(alertInfo.fixPath[0].path,"container_ndx",format_int(i,10)), "value":alertInfo.fixPath[0].value}, {"path":replace(alertInfo.fixPath[1].path,"container_ndx",format_int(i,10)), "value":alertInfo.fixPath[1].value}]{
	count(alertInfo.fixPath) == 2
} else = [{"path":replace(alertInfo.fixPath[0].path,"container_ndx",format_int(i,10)), "value":alertInfo.fixPath[0].value}] {
	count(alertInfo.fixPath) == 1
}  else = []





#################################################################################

# Check if appArmor or SELinux or seccompProfile is used
# Fails if none of them is used
is_no_SELinux_No_AppArmor_Pod(pod){
    not pod.spec.securityContext.seLinuxOptions
	annotations := [pod.metadata.annotations[i] | annotaion = i; startswith(i, "container.apparmor.security.beta.kubernetes.io")]
	not count(annotations) > 0
}

is_no_SELinux_container(container){
    not container.securityContext.seLinuxOptions
}

is_no_seccomp_pod(pod) {
    not pod.spec.securityContext.seccompProfile
}

is_no_Seccomp_Container(container) {
    not container.securityContext.seccompProfile
}






#################################################################################
# Workload evaluation 

evaluate_workload_non_root_container(container, pod, beggining_of_path) = alertInfo {
	runAsNonRootValue := get_run_as_non_root_value(container, pod, beggining_of_path)
	runAsNonRootValue.value == false
	
	runAsUserValue := get_run_as_user_value(container, pod, beggining_of_path)
	runAsUserValue.value == 0

	alertInfo := choose_first_if_defined(runAsUserValue, runAsNonRootValue)
} else = alertInfo {
    allowPrivilegeEscalationValue := get_allow_privilege_escalation(container, pod, beggining_of_path)
    allowPrivilegeEscalationValue.value == true

    alertInfo := allowPrivilegeEscalationValue
}


#################################################################################

# Checking for non-root and allowPrivilegeEscalation enabled
get_run_as_non_root_value(container, pod, beggining_of_path) = runAsNonRoot {
    failed_path := sprintf("%v.containers[container_ndx].securityContext.runAsNonRoot", [beggining_of_path]) 
    runAsNonRoot := {"value" : container.securityContext.runAsNonRoot, "failed_path" : failed_path, "fixPath": [] ,"defined" : true}
} else = runAsNonRoot {
	failed_path := sprintf("%v.containers[container_ndx].securityContext.runAsNonRoot", [beggining_of_path]) 
    runAsNonRoot := {"value" : pod.spec.securityContext.runAsNonRoot,  "failed_path" : failed_path, "fixPath": [], "defined" : true}
} else = {"value" : false,  "failed_path" : "", "fixPath": [{"path": "spec.securityContext.runAsNonRoot", "value":"true"}], "defined" : false} {
	is_allow_privilege_escalation_field(container, pod)
} else = {"value" : false,  "failed_path" : "", "fixPath": [{"path":  sprintf("%v.containers[container_ndx].securityContext.runAsNonRoot", [beggining_of_path]) , "value":"true"}, {"path":sprintf("%v.containers[container_ndx].securityContext.allowPrivilegeEscalation", [beggining_of_path]), "value":"false"}], "defined" : false}

get_run_as_user_value(container, pod, beggining_of_path) = runAsUser {
	failed_path := sprintf("%v.containers[container_ndx].securityContext.runAsUser", [beggining_of_path]) 
    runAsUser := {"value" : container.securityContext.runAsUser,  "failed_path" : failed_path,  "fixPath": [], "defined" : true}
} else = runAsUser {
	failed_path := sprintf("%v.containers[container_ndx].securityContext.runAsUser", [beggining_of_path]) 
    runAsUser := {"value" : pod.spec.securityContext.runAsUser,  "failed_path" : failed_path, "fixPath": [],"defined" : true}
} else = {"value" : 0, "failed_path": "", "fixPath": [{"path":  sprintf("%v.containers[container_ndx].securityContext.runAsNonRoot", [beggining_of_path]), "value":"true"}],"defined" : false}{
	is_allow_privilege_escalation_field(container, pod)
} else = {"value" : 0, "failed_path": "", 
	"fixPath": [{"path":  sprintf("%v.securityContext.containers[container_ndx].runAsNonRoot", [beggining_of_path]), "value":"true"},{"path":  sprintf("%v.containers[container_ndx].securityContext.allowPrivilegeEscalation", [beggining_of_path]), "value":"false"}],
	"defined" : false}

get_run_as_group_value(container, pod, beggining_of_path) = runAsGroup {
	failed_path := sprintf("%v.containers[container_ndx].securityContext.runAsGroup", [beggining_of_path])
    runAsGroup := {"value" : container.securityContext.runAsGroup,  "failed_path" : failed_path, "fixPath": [],"defined" : true}
} else = runAsGroup {
	failed_path := sprintf("%v.containers[container_ndx].securityContext.runAsGroup", [beggining_of_path])
    runAsGroup := {"value" : pod.spec.securityContext.runAsGroup,  "failed_path" : failed_path, "fixPath":[], "defined" : true}
} else = {"value" : 0, "failed_path": "", "fixPath": [{"path": "spec.securityContext.runAsNonRoot", "value":"true"}], "defined" : false}{
	is_allow_privilege_escalation_field(container, pod)
} else = {"value" : 0, "failed_path": "", 
	"fixPath": [{"path": sprintf("%v.containers[container_ndx].securityContext.runAsNonRoot", [beggining_of_path]), "value":"true"},{"path": sprintf("%v.securityContext.allowPrivilegeEscalation", [beggining_of_path]), "value":"false"}],
 	"defined" : false
}

get_allow_privilege_escalation(container, pod, beggining_of_path) = allowPrivilegeEscalation {
	failed_path := sprintf("%v.containers[container_ndx].securityContext.allowPrivilegeEscalation", [beggining_of_path])
    allowPrivilegeEscalation := {"value" : container.securityContext.allowPrivilegeEscalation,  "failed_path" : failed_path, "fixPath": [],"defined" : true}
} else = allowPrivilegeEscalation {
	failed_path := sprintf("%v.securityContext.allowPrivilegeEscalation", [beggining_of_path])
    allowPrivilegeEscalation := {"value" : pod.spec.securityContext.allowPrivilegeEscalation,  "failed_path" : failed_path, "fixPath": [],"defined" : true}
} else = {"value" : true, "failed_path": "", "fixPath": [{"path": sprintf("%v.securityContext.allowPrivilegeEscalation", [beggining_of_path]), "value":"false"}], "defined" : false}

choose_first_if_defined(l1, l2) = c {
    l1.defined
    c := l1
} else = l2


is_allow_privilege_escalation_field(container, pod) {
	container.securityContext.allowPrivilegeEscalation == false
}

is_allow_privilege_escalation_field(container, pod) {
	pod.spec.securityContext.allowPrivilegeEscalation == false
}
